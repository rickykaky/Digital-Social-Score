# Cloud Build Configuration for Digital Social Score
# Workflow: Tests ‚Üí Docker Build ‚Üí Registry Push ‚Üí Kubernetes Deploy
# Reference: https://cloud.google.com/build/docs

# ============================================================================
# VARIABLES GLOBALES
# ============================================================================
substitutions:
  _REGION: 'us-west1'
  _AR_REPO: 'social-score-repo'
  _IMAGE_NAME: 'social-score-api'
  _CLUSTER_NAME: 'social-score-cluster'
  _CLUSTER_ZONE: 'us-west1-a'
  _GKE_NAMESPACE: 'default'
  _DEPLOYMENT_NAME: 'social-score-deployment'
  _PIPELINE_REGION: 'us-central1'

options:
  machineType: 'N1_HIGHCPU_8'
  logging: CLOUD_LOGGING_ONLY

# ============================================================================
# √âTAPE 0 : TESTS (Python 3.11)
# ============================================================================
# Installe les d√©pendances et ex√©cute les tests
- name: 'python:3.11'
  id: 'run-tests'
  entrypoint: bash
  args:
    - '-c'
    - |
      set -e  # Exit on error
      
      echo "================================"
      echo "üß™ √âTAPE 0 : EX√âCUTION DES TESTS"
      echo "================================"
      
      # Installer les d√©pendances
      echo "üì¶ Installation des d√©pendances..."
      pip install -q -r requirements.txt
      pip install -q -r requirements-test.txt
      
      # T√©l√©charger les donn√©es NLTK
      echo "üì• T√©l√©chargement des donn√©es NLTK..."
      python -m nltk.downloader -q punkt stopwords wordnet averaged_perceptron_tagger maxent_ne_chunker
      
      # Ex√©cuter les tests
      echo "üß™ Ex√©cution des tests..."
      pytest tests/ -v --tb=short --junit-xml=test-results.xml || EXIT_CODE=$?
      
      if [ ! -z "$EXIT_CODE" ] && [ "$EXIT_CODE" != "0" ]; then
        echo "‚ùå Les tests ont √©chou√©!"
        exit 1
      fi
      
      echo "‚úÖ Tous les tests sont pass√©s!"
  waitFor: ['-']

# ============================================================================
# √âTAPE 1 : COMPILATION & SOUMISSION DU PIPELINE KFP (Cloud SDK)
# ============================================================================
# Compile le pipeline Kubeflow v2 et le soumet √† Vertex AI
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  id: 'compile-pipeline'
  entrypoint: bash
  args:
    - '-c'
    - |
      set -e
      
      echo "==========================================="
      echo "üîÑ √âTAPE 1 : COMPILATION DU PIPELINE KFP"
      echo "==========================================="
      
      # D√©finir les variables
      export PROJECT_ID=${PROJECT_ID}
      export PIPELINE_REGION=${_PIPELINE_REGION}
      export BUCKET_NAME=${PROJECT_ID}-digital-social-score
      export COMMIT_SHA=${COMMIT_SHA}
      
      # Cr√©er le bucket GCS s'il n'existe pas
      echo "ü™£ V√©rification du bucket GCS..."
      if ! gsutil ls gs://${BUCKET_NAME} > /dev/null 2>&1; then
        echo "üì¶ Cr√©ation du bucket GCS: ${BUCKET_NAME}"
        gsutil mb -l ${PIPELINE_REGION} gs://${BUCKET_NAME}
      fi
      
      # Installer KFP et Vertex AI
      echo "ÔøΩ Installation des d√©pendances KFP..."
      pip install -q kfp==2.0.0 google-cloud-aiplatform
      
      # Compiler le pipeline
      echo "üî® Compilation du pipeline KFP..."
      cd src/
      python -c "
from kfp.v2 import compiler
from pipeline import digital_score_pipeline
import os

try:
    compiler.Compiler().compile(
        pipeline_func=digital_score_pipeline,
        package_path='digital_score_pipeline.yaml'
    )
    print('‚úÖ Pipeline compil√© avec succ√®s!')
    print(f'üìÑ Fichier: {os.path.abspath(\"digital_score_pipeline.yaml\")}')
except Exception as e:
    print(f'‚ùå Erreur lors de la compilation: {e}')
    import traceback
    traceback.print_exc()
    exit(1)
      "
      
      # V√©rifier que le fichier compil√© existe
      if [ ! -f digital_score_pipeline.yaml ]; then
        echo "‚ùå Erreur: digital_score_pipeline.yaml non trouv√©"
        exit 1
      fi
      
      # Copier le fichier compil√© pour le stockage
      echo "üíæ Stockage du pipeline compil√©..."
      gsutil cp digital_score_pipeline.yaml gs://${BUCKET_NAME}/pipeline-templates/digital_score_pipeline-${COMMIT_SHA}.yaml
      
      # Soumettre le pipeline √† Vertex AI (optionnel)
      echo "üì§ Soumission du pipeline √† Vertex AI..."
      python submit_pipeline.py \
        --project ${PROJECT_ID} \
        --region ${PIPELINE_REGION} \
        --name "digital-social-score-${COMMIT_SHA:0:7}" \
        --bucket ${BUCKET_NAME} \
        --template gs://${BUCKET_NAME}/pipeline-templates/digital_score_pipeline-${COMMIT_SHA}.yaml || \
        echo "‚ö†Ô∏è  Impossible de soumettre le pipeline (optionnel - peut √™tre configur√© plus tard)"
      
      echo "‚úÖ Pipeline compil√© et soumis!"
  waitFor: ['run-tests']

# ============================================================================
# √âTAPE 2 : CONSTRUCTION DE L'IMAGE DOCKER
# ============================================================================
# Build l'image Docker et la tag avec le COMMIT_SHA et 'latest'
- name: 'gcr.io/cloud-builders/docker'
  id: 'build-image'
  args:
    - 'build'
    - '-t'
    - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:${COMMIT_SHA}'
    - '-t'
    - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:latest'
    - '-f'
    - 'Dockerfile'
    - '.'
  waitFor: ['compile-pipeline']

# ============================================================================
# √âTAPE 3 : PUSH VERS ARTIFACT REGISTRY
# ============================================================================
# Pousse l'image Docker vers Google Artifact Registry
- name: 'gcr.io/cloud-builders/docker'
  id: 'push-image'
  args:
    - 'push'
    - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:${COMMIT_SHA}'
  waitFor: ['build-image']

# ============================================================================
# √âTAPE 4 : CONFIGURATION GKE & D√âPLOIEMENT
# ============================================================================
# Configure kubectl et met √† jour le d√©ploiement Kubernetes
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  id: 'deploy-to-gke'
  entrypoint: bash
  args:
    - '-c'
    - |
      set -e
      
      echo "=========================================="
      echo "‚ò∏Ô∏è  √âTAPE 4 : D√âPLOIEMENT SUR GKE"
      echo "=========================================="
      
      # 1. Configuration kubectl pour acc√©der au cluster GKE
      echo "üîê Configuration de kubectl..."
      gcloud container clusters get-credentials ${_CLUSTER_NAME} \
        --zone ${_CLUSTER_ZONE} \
        --project ${PROJECT_ID}
      
      # 2. V√©rifier que le d√©ploiement existe
      echo "‚úì V√©rification du d√©ploiement..."
      if ! kubectl get deployment ${_DEPLOYMENT_NAME} -n ${_GKE_NAMESPACE} > /dev/null 2>&1; then
        echo "‚ö†Ô∏è  Le d√©ploiement ${_DEPLOYMENT_NAME} n'existe pas!"
        echo "üìù Veuillez cr√©er le d√©ploiement manuellement ou utiliser une manifeste."
        exit 0
      fi
      
      # 3. Mise √† jour de l'image Docker dans le d√©ploiement Kubernetes
      echo "üîÑ Mise √† jour de l'image Docker..."
      kubectl set image \
        deployment/${_DEPLOYMENT_NAME} \
        ${_IMAGE_NAME}=${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:${COMMIT_SHA} \
        -n ${_GKE_NAMESPACE}
      
      # 4. Attendre la fin du Rolling Update
      echo "‚è≥ Attente du d√©ploiement (timeout: 5 minutes)..."
      kubectl rollout status \
        deployment/${_DEPLOYMENT_NAME} \
        -n ${_GKE_NAMESPACE} \
        --timeout=5m
      
      # 5. Afficher le statut du d√©ploiement
      echo ""
      echo "üìä Statut du d√©ploiement:"
      kubectl get deployment ${_DEPLOYMENT_NAME} -n ${_GKE_NAMESPACE}
      kubectl get pods -l app=${_IMAGE_NAME} -n ${_GKE_NAMESPACE}
      
      echo "‚úÖ D√©ploiement termin√© avec succ√®s!"
  waitFor: ['push-image']

# ============================================================================
# √âTAPE 5 : V√âRIFICATION FINALE
# ============================================================================
# V√©rifie que le d√©ploiement fonctionne correctement
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  id: 'verify-deployment'
  entrypoint: bash
  args:
    - '-c'
    - |
      echo "‚úÖ Pipeline CI/CD COMPLET!"
      echo ""
      echo "üìã R√©sum√©:"
      echo "  - ‚úÖ Tests ex√©cut√©s et valid√©s"
      echo "  - ‚úÖ Pipeline KFP compil√© et soumis"
      echo "  - ‚úÖ Image Docker construite: ${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:${COMMIT_SHA}"
      echo "  - ‚úÖ Image pouss√©e vers Artifact Registry"
      echo "  - ‚úÖ D√©ploiement mis √† jour sur GKE"
      echo ""
      echo "üîó Ressources:"
      echo "  - Artifact Registry: https://console.cloud.google.com/artifacts"
      echo "  - GKE Cluster: https://console.cloud.google.com/kubernetes/clusters"
      echo "  - Vertex AI Pipelines: https://console.cloud.google.com/vertex-ai/pipelines"
  waitFor: ['deploy-to-gke']

# ============================================================================
# IMAGES DE SORTIE
# ============================================================================
# Images push√©es vers Artifact Registry
images:
  - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:${COMMIT_SHA}'
  - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_AR_REPO}/${_IMAGE_NAME}:latest'

# ============================================================================
# CONFIGURATION TIMEOUT & ARTIFACTS
# ============================================================================
timeout: '1800s'  # 30 minutes

artifacts:
  objects:
    location: 'gs://${PROJECT_ID}-cloud-build-logs'
    paths:
      - 'test-results.xml'
      - 'src/digital_score_pipeline.yaml'
